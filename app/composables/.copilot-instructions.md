# Composables Instructions - Petsgram

> **Note**: Please update this file as composable patterns evolve. Last updated: January 3, 2026

## Composables Overview

Composables in Petsgram follow a strict architectural pattern focused on reusability, type safety, and separation of concerns. All business logic should be encapsulated in composables rather than in components.

## File Structure and Organization

### Directory Structure

Each composable lives in its own directory with related files:

```
app/composables/
  useRegister/
    useRegister.ts        # Main composable logic
    useRegister.types.ts  # Type definitions
  useUser/
    useUser.ts
  useAuth/
    useAuth.ts
    useAuth.types.ts
```

### Naming Conventions

- **Composable functions**: Prefix with `use` + PascalCase (e.g., `useRegister`, `useAuth`)
- **Type files**: Match composable name with `.types.ts` suffix
- **Boolean state**: Prefix with `is` (e.g., `isLoading`, `isError`)
- **Error messages**: Suffix with `ErrorMessage` (e.g., `signUpErrorMessage`)
- **Async functions**: Use imperative verbs (e.g., `registerUser`, `fetchProfile`, `updateSettings`)

## Composable Pattern

### Basic Structure

Every composable should follow this pattern:

```typescript
import type { YourPayload } from './useYourComposable.types'

export const useYourComposable = () => {
  // 1. Dependencies (other composables, Supabase client, etc.)
  const supabaseClient = useSupabaseClient()
  
  // 2. Reactive state (always use ref() for primitives)
  const isLoading = ref(false)
  const isError = ref(false)
  const errorMessage = ref('')
  
  // 3. Helper functions (private, not exposed)
  const helperFunction = async () => {
    // Implementation
  }
  
  // 4. Public methods
  const mainMethod = async (data: YourPayload) => {
    isLoading.value = true
    
    try {
      // Your logic here
    } catch (error) {
      // Error handling
      errorMessage.value = 'User-friendly error message'
      isError.value = true
    } finally {
      isLoading.value = false
    }
  }
  
  // 5. Return object (methods + state)
  return {
    mainMethod,
    isLoading,
    isError,
    errorMessage
  }
}
```

## Real Example: useRegister

### Main Composable (`useRegister.ts`)

```typescript
import { RegisterError } from '@/errors/RegisterError.error'
import type { RegisterPayload } from './useRegister.types'

export const useRegister = () => {
  const supabaseClient = useSupabaseClient()
  const isSigningUp = ref(false)
  const isSignUpError = ref(false)
  const signUpErrorMessage = ref('')

  const verifyIfUserExists = async (email: string, username?: string) => {
    const credentialsMatch = {
      email: false,
      username: false
    }

    let query = supabaseClient
      .from('profiles')
      .select('email, username')

    if (username) {
      query = query.or(`email.eq.${email},username.eq.${username}`)
    } else {
      query = query.eq('email', email)
    }

    const { data, error } = await query

    if (error) {
      console.log('Error checking existing user by email:', error)
      throw error
    }

    credentialsMatch.email = data?.some(profile => profile.email === email)
    credentialsMatch.username = data?.some(profile => profile.username === username)

    return credentialsMatch
  }

  const registerUser = async (data: RegisterPayload) => {
    isSigningUp.value = true

    try {
      const userExists = await verifyIfUserExists(data.email, data.username)

      if (userExists.email && userExists.username) {
        throw new RegisterError('User with this email and username already exists')
      }

      if (userExists.email) {
        throw new RegisterError('User with this email already exists')
      }

      if (userExists.username) {
        throw new RegisterError('User with this username already exists')
      }

      const { error } = await supabaseClient.auth.signUp({
        email: data.email,
        password: data.password,
        options: {
          data: {
            username: data.username
          }
        }
      })

      if (error) throw error
    } catch (error) {
      signUpErrorMessage.value = error instanceof RegisterError 
        ? error.message 
        : 'Registration error. Please check your details and try again.'
      isSignUpError.value = true
    } finally {
      isSigningUp.value = false
    }
  }

  return {
    registerUser,
    isSigningUp,
    isSignUpError,
    signUpErrorMessage
  }
}
```

### Type Definitions (`useRegister.types.ts`)

```typescript
export type RegisterPayload = {
  username: string
  email: string
  password: string
}
```

### Custom Error Class (`errors/RegisterError.error.ts`)

```typescript
export class RegisterError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'RegisterError'
  }
}
```

## State Management Patterns

### Use ref() for Primitives

Always use `ref()` for primitive values (strings, numbers, booleans):

```typescript
const isLoading = ref(false)
const errorMessage = ref('')
const count = ref(0)
```

### State Reset Pattern

Use the `finally` block to ensure state is always reset:

```typescript
const performAction = async () => {
  isLoading.value = true
  
  try {
    // Action logic
  } catch (error) {
    // Error handling
  } finally {
    isLoading.value = false  // Always reset loading state
  }
}
```

### Multiple State Flags

Use separate boolean refs for different states rather than a single status enum:

```typescript
// ✅ Good: Separate flags
const isLoading = ref(false)
const isError = ref(false)
const isSuccess = ref(false)

// ❌ Avoid: Single status
const status = ref<'idle' | 'loading' | 'error' | 'success'>('idle')
```

## Error Handling Patterns

### Multi-Layered Error Handling

1. **Create custom error classes** for domain-specific errors
2. **Use instanceof checks** to differentiate error types
3. **Provide user-friendly messages** for all error scenarios
4. **Expose error state** via refs, don't throw to caller

```typescript
try {
  // Validation checks
  if (someCondition) {
    throw new CustomError('Specific validation message')
  }
  
  // API call
  const { data, error } = await supabaseClient.from('table').select()
  
  if (error) throw error
} catch (error) {
  // Differentiate error types
  errorMessage.value = error instanceof CustomError
    ? error.message
    : 'Generic fallback message for unexpected errors'
  isError.value = true
}
```

### Error Message Priority

1. Custom error messages (highest priority)
2. Supabase error messages
3. Generic fallback messages (lowest priority)

## Supabase Integration Patterns

### Client Access

Always use the `useSupabaseClient()` composable:

```typescript
const supabaseClient = useSupabaseClient()
```

### Query Building

Use fluent API with conditional query building:

```typescript
let query = supabaseClient
  .from('profiles')
  .select('email, username')

// Conditional filters
if (username) {
  query = query.or(`email.eq.${email},username.eq.${username}`)
} else {
  query = query.eq('email', email)
}

const { data, error } = await query
```

### Authentication Methods

```typescript
// Sign up with metadata
const { error } = await supabaseClient.auth.signUp({
  email: data.email,
  password: data.password,
  options: {
    data: {
      username: data.username,
      // Additional metadata
    }
  }
})

// Sign in
const { error } = await supabaseClient.auth.signInWithPassword({
  email: data.email,
  password: data.password
})

// Sign out
const { error } = await supabaseClient.auth.signOut()
```

### Error Checking

Always destructure and check for errors:

```typescript
const { data, error } = await supabaseClient
  .from('profiles')
  .select('*')

if (error) {
  console.error('Database query error:', error)
  throw error
}

// Use data safely here
```

## Type Safety

### Import Types

Use `import type` for type-only imports:

```typescript
import type { RegisterPayload } from './useRegister.types'
import type { Database } from '@/types/database.types'
```

### Type Definitions Structure

Keep types simple and focused:

```typescript
// ✅ Good: Simple, focused type
export type RegisterPayload = {
  username: string
  email: string
  password: string
}

// ✅ Good: Descriptive suffix
export type UserProfile = {
  id: string
  username: string
  email: string
}

export type UpdateProfilePayload = {
  username?: string
  bio?: string
  avatar?: string
}
```

### Return Type Inference

Let TypeScript infer return types for composables:

```typescript
// ✅ Good: Inferred return type
export const useRegister = () => {
  // ...
  return {
    registerUser,
    isSigningUp,
    isSignUpError,
    signUpErrorMessage
  }
}

// ❌ Avoid: Explicit return type (unnecessary)
export const useRegister = (): UseRegisterReturn => {
  // ...
}
```

## Component Usage

### Destructuring in Components

```vue
<script setup lang="ts">
const { 
  registerUser, 
  isSigningUp, 
  isSignUpError, 
  signUpErrorMessage 
} = useRegister()

const handleSubmit = async () => {
  await registerUser({
    username: 'johndoe',
    email: 'john@example.com',
    password: 'securePassword123'
  })
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <!-- Form fields -->
    <button :disabled="isSigningUp">
      {{ isSigningUp ? 'Signing up...' : 'Sign Up' }}
    </button>
    <p v-if="isSignUpError" class="error">
      {{ signUpErrorMessage }}
    </p>
  </form>
</template>
```

## Best Practices

1. **Single Responsibility**: Each composable should have one clear purpose
2. **Separation of Concerns**: Keep types in separate files
3. **Error Boundaries**: Handle all errors within the composable
4. **State Cleanup**: Always reset state in `finally` blocks
5. **Type Safety**: Use TypeScript for all composable logic
6. **Naming Consistency**: Follow established naming patterns
7. **Documentation**: Add JSDoc comments for complex logic
8. **Testing**: Write unit tests for composable logic

## Placeholder Sections (To Be Completed)

### Composable Testing

<!-- TODO: Document testing patterns for composables, mocking Supabase, testing error scenarios -->

### Advanced Patterns

<!-- TODO: Document composable composition, shared state between composables, watchers and computed -->

### Performance Optimization

<!-- TODO: Document debouncing, throttling, cleanup patterns, memory leaks prevention -->

---

**Remember**: Update this file when introducing new patterns or making architectural decisions about composables.
